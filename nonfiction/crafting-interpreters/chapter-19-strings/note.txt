01/18/2025

Right now, we represent numbers, Booleans, and nil.
These values are all immutable and small

Strings have no maximum length and even if we
limit the length to something like 255 characters, that
is still very big for a single value
        UCSD Pascal did this. Strings started with a length
        value. Since it only used a single byte to store
        the length, strings couldn't be any longer than 255
        characters

We need a way to support values whose sizes vary, sometimes
greatly. This is what dynamic allocation on the heap was
designed for. We can allocate as many bytes as we need

01/19/2025
19.1: Values and Objects
        Two levels of value representation
                Heap for larger, variable-sized values

                Stack for smaller, atomic ones

        Every Lox value that can be stored in a variable or
        return from an expression will be a Value

        Small, fixed-size types like numbers will store the
        value directly in the Value struct

        If the object is larger, its data lives on the heap.
        Then the Value's payload is a pointer to that blob of
        memory
                Ex: Strings, instances, functions

        Add VAL_OBJ enum variation to ValueType enum in value.h
                Heap stored values, ValueType should store a pointer

        Add Obj* to union in Value struct in value.h

        Add IS_OBJ, AS_OBJ, and OBJ_VAL macros to value.h

19.2: Struct Inheritance
        Every heap-allocated value is an Obj, but Objs are not all the same
                Strings need an array of characters

                Instances need data fields

                Function objects need different data

        How do we handle different payloads and sizes?
                Can't use another union like we did for Value
                since sizes are so varied

        Type punning
                C specification has support for it

                We will call this struct inheritance

                Roughly follows how single-inheritance of state
                works in object-oriented languages

        Each Obj starts with a tag field that identifies what kind
        of object it is. Following that are the payload fields.
        Instead of a union with cases for each type, each type
        is its own seperate struct. Each struct has to be treated
        uniformly even though C has no concept of inheritance or
        polymorphism

        Add Obj typedef in value.h

        Create object.h file
                Obj struct

                ObjType enum

                OBJ_TYPE macro

                ObjString struct

        Add ObjString typedef to value.h

        A string object contains an array of characters.
        We also store the length so we don't have to go through
        the character array to find the null terminal

        Because ObjString is an Obj, it also needs the state all
        Objs share. It does this by having its first field be an
        Obj. C specifies that struct fields are arranged in memory
        in the order they are declared. Also, when you nest structs,
        the inner struct's fields are expanded right in place

        For ObjString and Obj, this means for the memory for both,
        they start with the Obj struct data. This enables the ability
        to take a pointer to a struct and safely convert it to a pointer
        to its first field and back
                Given an ObjString* you can safely cast it to Obj* and
                then access the type field from it. Every ObjString "is"
                an Obj in the OOP sense of "is"

        When we add other object types, each one will have Obj as its first
        field. Any code that wants to work with all objects can treat them
        as base Obj* and ignore any other fields that may happen to follow

        You can also "downcast" Obj* to an ObjString*. The only thing
        you need to ensure is that the Obj* pointer does point to the
        obj field of an actual ObjString

        Add IS_STRING macro and isObjType function to object.h
                isObjType is a function instead of in IS_STRING
                because in macros, it is expanded by inserting
                the argument expression every
                place the parameter name appears in the body.

        ADD AS_STRING and AS_CSTRING macros to object.h

                If we did IS_STRING(POP()) it would pop from
                the stack twice
01/20/2025

19.3: Strings
        Add string function to compiler.c

        Add object.c
                copyString function

        Add Allocate macro to memory.h

        Why doesn't ObjString point to the original string passed in
        to copyString instead of allocating? Some ObjStrings will be
        created dynamically at runtime as a result of string operations
        like concatenation. Those strings need to dynamically allocate
        memory and free that memory when its no longer needed

        If we had a ObjString for a string literal that was part of the
        source code, bad things would happen. For literals we preemptively
        copy the characters over the heap so that ObjString owns its
        own character array and can free it

        Add allocateString function to object.c

        Add ALLOCATE_OBJ macro to object.c

        Add allocateObject function to object.c

19.4: Operations on Strings
        Add VAL_OBJ switch case in printValue function in value.c

        Add printObject function to object.h and object.c

        Equality between two strings should work
                "string" == "string" should return true

        ADD VAL_OBJ switch case to valuesEqual function in value.c

        19.4.1: Concatenation
                Using + on two strings should combine them together
                Ex:
                        "Hello, " + "World!" = "Hello, World!"

                Alter OP_ADD switch case in run function in vm.c

                Add concatenate function to vm.c

                Add takeString function to object.h / object.c
                        Avoids extra allocation for char, pass one in
                        direction

01/27/2025
19.5: Freeing Objects
        Take the following string concat example:
                "st" + "ri" + "ng"

                For each string constant, it allocates a ObjString for each
                of the three string literals and stores them in the chunk's constant
                table and generates the following bytecode:

                        0000    OP_CONSTANT         0 "st"
                        0002    OP_CONSTANT         1 "ri"
                        0004    OP_ADD
                        0005    OP_CONSTANT         2 "ng"
                        0007    OP_ADD
                        0008    OP_RETURN
